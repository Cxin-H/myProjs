/*!
 * Copyright Massmotionmedia - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * 
 * Date : 2018-09-11
 * Version: 1.2.3 new
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, setImmediate) {
// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(10).setImmediate))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var asap = __webpack_require__(0);

module.exports = Promise;

function Promise(fn) {
  if (_typeof(this) !== 'object') throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  var state = null;
  var value = null;
  var deferreds = [];
  var self = this;

  this.then = function (onFulfilled, onRejected) {
    return new self.constructor(function (resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject));
    });
  };

  this.always = this.done;
  this.done = this.then;
  this.fail = this.catch;

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred);
      return;
    }

    asap(function () {
      var cb = state ? deferred.onFulfilled : deferred.onRejected;

      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value);
        return;
      }

      var ret;

      try {
        ret = cb(value);
      } catch (e) {
        deferred.reject(e);
        return;
      }

      deferred.resolve(ret);
    });
  }

  function resolve(newValue) {
    try {
      //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');

      if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;

        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject);
          return;
        }
      }

      state = true;
      value = newValue;
      finale();
    } catch (e) {
      reject(e);
    }
  }

  function reject(newValue) {
    state = false;
    value = newValue;
    finale();
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++) {
      handle(deferreds[i]);
    }

    deferreds = null;
  }

  doResolve(fn, resolve, reject);
}

function Handler(onFulfilled, onRejected, resolve, reject) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.resolve = resolve;
  this.reject = reject;
}
/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */


function doResolve(fn, onFulfilled, onRejected) {
  var done = false;

  try {
    fn(function (value) {
      if (done) return;
      done = true;
      onFulfilled(value);
    }, function (reason) {
      if (done) return;
      done = true;
      onRejected(reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    onRejected(ex);
  }
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var asap = __webpack_require__(0)

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }
  
  this.always = this.done;
  this.done = this.then;
  this.fail = this.catch;

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(1);

__webpack_require__(12);

__webpack_require__(13);

__webpack_require__(14);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = installMixpanel;

/** document, window.mixpanel || [] */
var installed = false;

function installMixpanel(base) {
  if (installed) return;else installed = true;
  var e = document;
  var a = window.mixpanel || [];

  if (!a.__SV) {
    var b = window;

    try {
      var c,
          l,
          i,
          j = b.location,
          g = j.hash;

      c = function c(a, b) {
        return (l = a.match(RegExp(b + "=([^&]*)"))) ? l[1] : null;
      };

      g && c(g, "state") && (i = JSON.parse(decodeURIComponent(c(g, "state"))), "mpeditor" === i.action && (b.sessionStorage.setItem("_mpcehash", g), history.replaceState(i.desiredHash || "", e.title, j.pathname + j.search)));
    } catch (m) {}

    var k, h;
    window.mixpanel = a;
    a._i = [];

    a.init = function (b, c, f) {
      function e(b, a) {
        var c = a.split(".");
        2 == c.length && (b = b[c[0]], a = c[1]);

        b[a] = function () {
          b.push([a].concat(Array.prototype.slice.call(arguments, 0)));
        };
      }

      var d = a;
      "undefined" !== typeof f ? d = a[f] = [] : f = "mixpanel";
      d.people = d.people || [];

      d.toString = function (b) {
        var a = "mixpanel";
        "mixpanel" !== f && (a += "." + f);
        b || (a += " (stub)");
        return a;
      };

      d.people.toString = function () {
        return d.toString(1) + ".people (stub)";
      };

      k = "disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");

      for (h = 0; h < k.length; h++) {
        e(d, k[h]);
      }

      a._i.push([b, c, f]);
    };

    a.__SV = 1.2;
    b = e.createElement("script");
    b.type = "text/javascript";
    b.async = !0;
    b.src = base + "/libs/mixpanel-2-latest.min.js";
    c = e.getElementsByTagName("script")[0];
    c.parentNode.insertBefore(b, c);
  }
}

;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(8);
__webpack_require__(24);
module.exports = __webpack_require__(6);


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promiseDeferred = _interopRequireDefault(__webpack_require__(9));

var _promise = _interopRequireDefault(__webpack_require__(4));

var _mixpanel = _interopRequireDefault(__webpack_require__(6));

var _utils = __webpack_require__(15);

__webpack_require__(20);

var _accounts = _interopRequireDefault(__webpack_require__(21));

var _mixpanel2 = _interopRequireDefault(__webpack_require__(22));

var _cdns = _interopRequireDefault(__webpack_require__(23));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Modules */
window.Promise = _promise.default;
var controller_url = null,
    parts = null;

if ((parts = getWidemotionScriptUrl()) !== null) {
  controller_url = parts[0];
} else {
  throw new Error("No controller found in page ! please check controller name");
}

var init_queue = [];
var event_queue = [];
var enqueue_timeout = null;
/**
 * @param {Response} response
 * @return {Promise}
 */

var middleware_parseJSON = function middleware_parseJSON(response) {
  return response.json();
};
/**
 * @param {Response} response
 * @return {Promise}
 */


var middleware_checkStatus = function middleware_checkStatus(response) {
  if (response.status >= 200 && response.status < 300) {
    return response;
  } else {
    var error = new Error(response.statusText);
    error.response = response;
    throw error;
  }
}; ///////////////////////////////////////////////////////////////////////////
// INTERFACE PUBLIQUE


var widemotion = {};
var isjQuery = false;

widemotion.attach = function (video_tag, widemotion_id, accounts, mixed_scheme_media) {
  var dfd = new _promiseDeferred.default();
  var error = "";

  if (!(video_tag instanceof HTMLVideoElement) && !(window.jQuery !== undefined && video_tag instanceof jQuery) && !(window.$ !== undefined && video_tag instanceof $)) {
    error = "attach 1st param must be a jquery or HTML Video object";
  } else if (video_tag.getAttribute && video_tag.getAttribute("id") === undefined && video_tag.attr && video_tag.attr("id") === undefined) {
    error = "attach 1st param object must have an id";
  } else if (typeof widemotion_id !== "string") {
    error = "attach 2nd param must be a string";
  } else if (re_word.exec(widemotion_id) === null) {
    error = "attach 2nd param must be a valid video identifier";
  } else if (!Array.isArray(accounts)) {
    error = "attach 3rd param must be an array";
  } else {
    if (accounts.length < 1) {
      error = "attach 3rd param must be an array of valid account identifier";
    } else {
      for (var i = 0; i < accounts.length; i++) {
        if (re_word.exec(accounts[i]) === null) {
          error = "attach 3rd param must be an array of valid account identifier";
        }
      }
    }
  }

  if (error !== "") {
    dfd.reject(error);
    log.error(error);
  } else {
    if (window.jQuery && (video_tag instanceof jQuery || (window.$ && video_tag instanceof $))) {
      video_tag = video_tag[0];
    }

    registerHook(video_tag, widemotion_id, accounts, dfd);
  }

  if (mixed_scheme_media !== undefined && mixed_scheme_media === "allow_mixed_content") {
    security_model = widemotion.SECURITY_MIXED;
  }

  (0, _mixpanel.default)(W.base);
  return dfd.promise;
};

widemotion.setVerboseLevel = function (level) {
  log.level = level;
}; ///////////////////////////////////////////////////////////////////////////
// UTILITAIRES
// fonctions de log


var log = {
  level: 0,
  // 0 = aucun output, 1 = error only, 2 = info, 3 = trace
  error: function error(msg) {
    if (this.level < 1) {
      return;
    }

    console.error("widemotion > " + msg);
  },
  info: function info(msg) {
    if (this.level < 2) {
      return;
    }

    console.log("widemotion > " + msg);
  },
  trace: function trace(msg) {
    if (this.level < 3) {
      return;
    }

    console.log("widemotion > " + msg);
  }
};
widemotion.VERBOSE_NONE = 0;
widemotion.VERBOSE_ERROR = 1;
widemotion.VERBOSE_INFO = 2;
widemotion.VERBOSE_TRACE = 3; // regexp basique (widemotion_id, account)

var re_word = /^\S*$/; // prefixe localstorage

var key_prefix = "widemotion:"; // pour retrocompatibilite système de stats

var legacy_platform = {
  de: "web",
  ti: "ipa",
  si: "ip4",
  ta: "and",
  sa: "and"
};
widemotion.SECURITY_HTTP = 0;
widemotion.SECURITY_MIXED = 1;
widemotion.SECURITY_HTTPS = 2;
var security_model = widemotion.SECURITY_HTTP; ///////////////////////////////////////////////////////////////////////////
//  MECANIQUE FONCTIONNELLE

var W = {
  video_tags: {},
  // les balises vidéos alimentées par nous
  accounts: {},
  ids: {},
  bitrate: {
    timestamp: 0,
    value: 0
  },
  cdn: "mmm",
  platform: "de",
  base: ""
};
widemotion.W = W;
var story_images_par_file = 25;
var story_ips = 0.5;
/*
       * ajoute/update une balise vidéo aux éléments gérés par nous
       */

function registerHook(video_tag, widemotion_id, accounts, dfd) {
  var attr_id = video_tag.getAttribute("widemotion_random_tag");

  if (attr_id == null) {
    attr_id = (0, _utils.randomString)(32);
    video_tag.setAttribute("widemotion_random_tag", attr_id);
  }

  var elt_id = video_tag.getAttribute("id") + "_" + attr_id;
  var time_registered = new Date().getTime();

  if (elt_id in W.video_tags) {
    log.trace("updating an existing element : " + elt_id + " with new id " + widemotion_id);
    W.video_tags[elt_id].widemotion_id = widemotion_id;
    W.video_tags[elt_id].dfd = dfd;
    W.video_tags[elt_id].video_tag.data("widemotionStep", "updating");
    W.video_tags[elt_id].time_registered = time_registered;
    W.video_tags[elt_id].video_tag.off("emptied", onVideoChanged);
  } else {
    W.video_tags[elt_id] = {
      video_tag: video_tag,
      widemotion_id: widemotion_id,
      dfd: dfd,
      time_registered: time_registered
    };
    video_tag.data("widemotionStep", "initial");
    log.trace("adding a new element : " + elt_id + " with id " + widemotion_id);
  }

  for (var i in accounts) {
    if (!isNaN(i) && !(accounts[i] in W.accounts)) {
      // si nouveau compte on commence par un peu d'administratif
      registerAccount(accounts[i], elt_id, accounts.length === 1);
    }
  }

  areAllAccountsReady().done(function () {
    registerIdentifier(elt_id, accounts.length === 1 ? accounts[0] : null);
  });
}
/*
       * ajout d'un compte widemotion, chargement du bitrate-control et de la liste des vidéos "enabled"
       */


function registerAccount(account, elt_id, once) {
  // On initialise le compte mixpanel pour chaque compte
  queueAccount(account);
  W.accounts[account] = {
    bitrate_capping: null,
    list: [],
    ready: false
  };
  var bitrate_capping_url = W.base + "/" + account + "/player/brcontrol.js";
  var bitrate_capping_key = key_prefix + account + ":brcontrol";
  var list_url = W.base + "/" + account + "/player/simple_list.js";
  var list_key = key_prefix + account + ":list";
  var bitrateloader = smartFetch(bitrate_capping_url, bitrate_capping_key, 24 * 60);
  bitrateloader.done(function (content) {
    W.accounts[account].bitrate_capping = content;
  });
  var loaders = [bitrateloader];

  if (!once) {
    var simplelistloader = smartFetch(list_url, list_key, 1);
    simplelistloader.done(function (content) {
      W.accounts[account].list = content;
      W.accounts[account].list.sort();
    });
    loaders.push(simplelistloader);
  }

  Promise.all(loaders).then(function () {
    W.accounts[account].ready = true;
  });
}
/*
       * ajout d'une vidéo via chargement de la micro list associée à la balise
       */


function registerIdentifier(elt_id, preferred_account) {
  var widemotion_id = W.video_tags[elt_id].widemotion_id;
  var error = "";

  if (widemotion_id in W.ids) {
    setupElement(elt_id);
    return;
  }

  function fetchVideoDescription(account, widemotion_id, elt_id, error) {
    var description_url = W.base + "/" + account + "/projects/" + widemotion_id + "/datas/description.js";
    var description_key = key_prefix + account + ":projects:" + widemotion_id;
    smartFetch(description_url, description_key, 10).done(function (content) {
      if (content === false) {
        log.error(error);
        W.video_tags[elt_id].dfd.reject(error);
        return;
      }

      W.ids[widemotion_id] = content;
      setupElement(elt_id);
    });
  }

  if (preferred_account !== null) {
    log.trace("direct description fetching : preferred account : " + preferred_account + " / " + widemotion_id);
    fetchVideoDescription(preferred_account, widemotion_id, elt_id, "did not enabled video : " + widemotion_id + " within account " + preferred_account);
    return;
  }

  var first = null;

  for (var account in W.accounts) {
    first = first === null ? account : first;

    if (W.accounts[account].list.indexOf(widemotion_id) > -1) {
      log.trace("list based description fetching : " + account + " / " + widemotion_id);
      fetchVideoDescription(account, widemotion_id, elt_id, "did not find video information for id " + elt_id);
      return;
    }
  } // Si la vidéo n'a pas été trouvé dans les listes, on tente un appel direct
  // et correspond par design au cas où on ne charge volontairement pas les
  // listes d'id


  log.trace("direct description fetching : default : " + first + " / " + widemotion_id);
  fetchVideoDescription(first, widemotion_id, elt_id, "did not find account with enabled video : " + widemotion_id);
}

function setupElement(elt_id) {
  var description = W.ids[W.video_tags[elt_id].widemotion_id];
  var videos = [];
  var i = 0;
  var error = "";

  for (i = 0; i < description.videos.length; i++) {
    if (description.videos[i].platforms.indexOf(W.platform) > -1) {
      videos.push(description.videos[i]);
      log.trace("setupElement > electing video " + description.videos[i].path + " due to platform " + description.videos[i].platforms.join(" - "));
    } else {
      log.trace("setupElement > rejecting video " + description.videos[i].path + " due to platform " + description.videos[i].platforms.join(" - "));
    }
  }

  if (videos.length < 1) {
    for (i = 0; i < description.videos.length; i++) {
      if (description.videos[i].platforms.indexOf("fa") > -1) {
        videos.push(description.videos[i]);
        log.trace("setupElement > fallback > electing video " + description.videos[i].path + " due to platform " + description.videos[i].platforms.join(" - "));
      } else {
        log.trace("setupElement > fallback > rejecting video " + description.videos[i].path + " due to platform " + description.videos[i].platforms.join(" - "));
      }
    }
  }

  if (videos.length < 1) {
    error = "did not find suitable videos for tag " + elt_id;
    log.error(error);
    W.video_tags[elt_id].dfd.reject(error);
    return;
  }

  var map_bitrate = videos.map(function (item, idx) {
    return {
      idx: idx,
      value: item.bitrate
    };
  });
  map_bitrate.sort(function (a, b) {
    return +(a.value > b.value) || +(a.value === b.value) - 1;
  });
  var videos_sorted = map_bitrate.map(function (item) {
    return videos[item.idx];
  });
  testBitrate().done(function () {
    var i = 0;
    var bitrate_capping = W.accounts[description.account].bitrate_capping;
    var bitrate = W.bitrate.value;
    var aleas = Math.round(Math.random() * 100);

    if (bitrate_capping !== null) {
      if (bitrate_capping.cdns.indexOf(W.cdn) > -1) {
        if (bitrate_capping.whitelist.indexOf(description.id) == -1) {
          if (bitrate_capping.blacklist.indexOf(description.id) > -1 || aleas > bitrate_capping.noControlRate) {
            bitrate = bitrate_capping.capBitrate;
          }
        }
      }
    }

    for (i = 0; i < videos_sorted.length; i++) {
      if (videos_sorted[i].bitrate > bitrate) {
        break;
      }
    }

    var video = videos_sorted[Math.max(0, i - 1)];
    var full_path = W.base + "/" + description.account + "/projects/" + description.id + "/videos/" + video.path;
    var storyboard_path = W.base + "/" + description.account + "/projects/" + description.id + "/datas/storyboard_0000.jpg";

    if (security_model === widemotion.SECURITY_MIXED) {
      full_path = full_path.replace("https://secure.", "http://wwcache.");
      storyboard_path = storyboard_path.replace("https://secure.", "http://wwcache.");
    }

    var legacy_quality = video.bitrate < 500 ? "bq_" : video.bitrate < 1600 ? "hq_" : "hd_";
    W.video_tags[elt_id].completions = {
      c0: false
    };
    W.video_tags[elt_id].video_tag.data("widemotionStep", "ready");
    W.video_tags[elt_id].video_tag.data("widemotionResource", description.id);
    W.video_tags[elt_id].video_tag.data("widemotionMedia", video.path);
    W.video_tags[elt_id].video_tag.data("widemotionQuality", legacy_quality + legacy_platform[W.platform]);
    W.video_tags[elt_id].video_tag.data("widemotionMbitrate", video.bitrate);
    W.video_tags[elt_id].video_tag.data("widemotionUbitrate", bitrate);
    W.video_tags[elt_id].video_tag.data("widemotionAccount", description.account);
    log.trace("adding event listeners to video_tag : " + elt_id);
    W.video_tags[elt_id].video_tag.addEventListener("timeupdate", onVideoTimeUpdated);
    W.video_tags[elt_id].video_tag.setAttribute("src", full_path);
    W.video_tags[elt_id].dfd.resolve({
      storyboard: {
        path: storyboard_path,
        count: Math.ceil(story_ips * video.duration / story_images_par_file),
        // 25 images par planche, 1 images par 2 seconde
        density: story_images_par_file,
        ips: story_ips
      },
      duration: video.duration,
      path: full_path
    });
  });
}

function onVideoTimeUpdated(event) {
  computeCompletionStat(event.currentTarget.id + "_" + event.currentTarget.getAttribute("widemotion_random_tag"), event.currentTarget.duration, event.currentTarget.currentTime);
}

widemotion.emulateVideoProgress = function (id, duration, currentTime) {
  computeCompletionStat(id, duration, currentTime);
};

function computeCompletionStat(elt_id, duration, currentTime) {
  var completion = Math.floor(100 * currentTime / duration);
  var video_current_time = Math.min(30 * 60 * 1000, Math.round(currentTime));

  if (!W.video_tags[elt_id].completions.c0) {
    W.video_tags[elt_id].completions.c0 = true;
    var time_now = new Date().getTime();
    var delay = Math.floor(time_now - W.video_tags[elt_id].time_registered);
    queueEvent("play_video", delay, elt_id);
    W.video_tags[elt_id].video_tag.addEventListener("emptied", onVideoChanged);
  }
}
/*
       * l'élément vidéo a été modifié par l'extérieur
       */


function onVideoChanged(event) {
  var elt_id = event.currentTarget.id;
  W.video_tags[elt_id].video_tag.removeEventListener("timeupdate", onVideoTimeUpdated);
  delete W.video_tags[elt_id];
  log.trace("unregistering video_tag : " + elt_id);
} ///////////////////////////////////////////////////////////////////////////
// UTILITAIRES MMM

/**
 * Charge un fichier image sur le CDN media et en détermine
 * - le cdn courant, déterminé via les headers http
 * - le debit, exprimé en kbps (même unité que les données widemotion)
 */


function testBitrate() {
  // debugger;
  var dfd = new _promiseDeferred.default();
  var time_start = new Date().getTime();

  if (time_start - W.bitrate.timestamp < 30 * 1000) {
    dfd.resolve();
  } else {
    var headers = {
      headers: {
        "accept-encoding": "identity"
      }
    };
    fetch(W.base + "/common/1.0/random_81000.js?cb=" + Math.floor(Math.random() * 1000000), headers).then(middleware_checkStatus).then(onFinished);
  }

  function onFinished(response) {
    // debugger;
    W.bitrate.timestamp = new Date().getTime();

    if (response.statusText !== "OK") {
      W.bitrate.value = 850;
      dfd.resolve();
    }

    var duration = W.bitrate.timestamp - time_start;
    var headers = response.headers;
    W.bitrate.value = Math.floor(0.9 * 8 * 1000 * parseInt(headers.get("content-length") || 81000) / (duration * 1024)); // kbps

    W.cdn = headers.get("x-cdn") || headers.get("X-cdn") || "mmm";
    dfd.resolve();
  }

  return dfd.promise;
}
/**
 * Charge un fichier widemotion ou le retrouve dans le localStorage
 * si chargement et cache_duration > 0 : le stocke en base64 (atob/btoa) dans le localStorage
 * Le callback a un argument : le contenu utile du fichier en JSON
 */


function smartFetch(url, key, cache_duration) {
  var dfd = new _promiseDeferred.default();
  var cached = jparse(localStorage.getItem(key));
  var content = "";
  var time_end = new Date().getTime();

  if (cached !== null) {
    if (time_end - cached.timestamp < cache_duration * 60 * 1000) {
      log.trace("smartFetch > fetched locally cached content from " + url);
      dfd.resolve(jparse(atob(cached.content)));
      return dfd.promise;
    }

    localStorage.removeItem(key);
  }

  fetch(url + "?cb=" + Math.floor(Math.random() * 1000000)).then(middleware_checkStatus).then(function (response) {
    response.text().then(function (data) {
      var clean = data.replace(/window(\['[a-zA-Z\.]*'\])(\['([a-zA-Z\.])*'\]|\..*)\(/, "");
      clean = clean.replace(/'/g, '"'); // temp problematic fix ?

      for (var account in W.accounts) {
        clean = clean.replace("mmm_simplelist_" + account + " = ", "");
      }

      clean = clean.replace(");", "");

      if (cache_duration > 0) {
        try {
          localStorage.setItem(key, JSON.stringify({
            timestamp: new Date().getTime(),
            content: btoa(clean)
          }));
        } catch (e) {
          log.trace("smartFetch > cannot cache content from " + url);
        }
      }

      log.trace("smartFetch > fetched remote content from " + url);
      dfd.resolve(jparse(clean));
    });
  }).catch(function (error) {
    log.error("smartFetch > unable to fetch url " + url);
    dfd.resolve(false);
  });
  return dfd.promise;
}

function getWidemotionScriptUrl() {
  /** Regex explanations => (PROTOCOL)(SUBDOMAIN).(DOMAIN).(EXTENSION)/common/(VERSION)/controller(MINIFIED ? .min : ).js */
  var re_script = /(https?:\/\/)(.+)\.(massmotionmedia|widemotion)\.(com|cn)\/common\/((\d\.?){2,})\/controller(\.min)?\.js/;
  var url_and_parts = null;
  var scripts = document.querySelectorAll("script");

  for (var i = 0, l = scripts.length; i < l; ++i) {
    var script_node = scripts[i];
    var src = script_node.getAttribute("src");
    var data = null;

    if ((data = re_script.exec(src)) !== null && url_and_parts === null) {
      url_and_parts = data;
    }
  }

  return url_and_parts;
}
/**
 * Retourne le "baseurl" utilisé pour l'appel au controller
 * ex : http://wwcache.massmotionmedia.com
 * ex : https://secure.massmotionmedia.com
 * ex : https://secure.massmotionmedia.cn
 * ex : https://secure.widemotion.cn
 */


function getWidemotionHostnameAndScheme() {
  /** Regex explanations => (PROTOCOL)(SUBDOMAIN).(DOMAIN).(EXTENSION) */
  var re_caller_cdn = /(https?:\/\/)(.+)\.(massmotionmedia|widemotion)\.(com|cn)/;
  /** Regex explanations => (anything)(DOMAIN)(anything) */

  var re_caller_domain = /.*(massmotionmedia|widemotion).*/;
  var groups;

  if ((groups = re_caller_cdn.exec(controller_url)) !== null) {
    if (groups[1].substr(0, 5).toLowerCase() === "https") {
      security_model = widemotion.SECURITY_HTTPS;
    } else {
      security_model = widemotion.SECURITY_HTTP;
    }

    return groups[1] + groups[2] + "." + groups[3] + "." + groups[4];
  } else {
    security_model = widemotion.SECURITY_HTTP;
    groups = re_caller_domain.exec(controller_url);

    if (groups.length === 0) {
      groups = [controller_url, "massmotiomedia"];
    }

    return "http://wwcache." + groups[1] + ".com";
  }
}
/*
       * Détermine le device/platform en accord avec les description vidéo
       */


function guessPlatform() {
  var re_ipad = /ipad/i;
  var re_iphone = /iphone/i;
  var re_android_phone = /android.*mobile/i;
  var re_android = /android/i;

  if (re_ipad.test(navigator.userAgent)) {
    W.platform = "ti";
  } else if (re_iphone.test(navigator.userAgent)) {
    W.platform = "si";
  } else if (re_android_phone.test(navigator.userAgent)) {
    W.platform = "sa";
  } else if (re_android.test(navigator.userAgent)) {
    W.platform = "ta";
  }
}
/*
       * Promise qui nous dit quand les comptes sont chargées
       */


function areAllAccountsReady() {
  var dfd = new _promiseDeferred.default();

  function check() {
    var ready = true;

    for (var i in W.accounts) {
      ready = ready && W.accounts[i].ready;
    }

    return ready;
  }

  var interval = setInterval(function () {
    if (check()) {
      clearInterval(interval);
      dfd.resolve();
    }
  }, 50);
  return dfd.promise;
}
/*
       * formatage d'une stat de completion video
       */


function formatCompletionEvent(duration_info, elt_id) {
  return {
    controller_url: controller_url,
    info_perf: _cdns.default[W.cdn] || _cdns.default.mmm,
    media: W.video_tags[elt_id].video_tag.data("widemotionMedia"),
    resource: W.video_tags[elt_id].video_tag.data("widemotionResource"),
    timetoview: duration_info,
    mediabitrate: W.video_tags[elt_id].video_tag.data("widemotionMbitrate"),
    userbitrate: W.video_tags[elt_id].video_tag.data("widemotionUbitrate")
  };
}
/*
       * envoi d'une stat via le système mixpanel
       */


function sendStatEvent(event_name, duration_info, elt_id) {
  var account = W.video_tags[elt_id].video_tag.data("widemotionAccount");
  var data = formatCompletionEvent(duration_info, elt_id);

  if (log.level >= widemotion.VERBOSE_TRACE) {
    log.trace("sendStatEvent > prevented : (account: " + account + ") " + event_name + " " + JSON.stringify(data));
    return false;
  }

  mixpanel[account].track(event_name, data);
  return true;
}
/*
       * Nettoyage du localStorage
       */


function cleanLocalStorage() {
  var time_now = new Date().getTime();
  var i = 0;
  var to_clean = [];

  for (i = 0; i < localStorage.length; i++) {
    var key = localStorage.key(i);

    if (key.substring(0, key_prefix.length) === key_prefix) {
      var cached = jparse(localStorage.getItem(key));

      if (cached === null || !("timestamp" in cached)) {
        to_clean.push(key);
      } else if (time_now - cached.timestamp > 24 * 60 * 60 * 1000) {
        to_clean.push(key);
      }
    }
  }

  for (i = 0; i < to_clean.length; i++) {
    localStorage.removeItem(to_clean[i]);
  }
}

function jparse(a_string) {
  try {
    return JSON.parse(a_string);
  } catch (e) {
    return null;
  }
} ///////////////////////////////////////////////////////////////////////////
// UTILITAIRES GESTION PRE-CORS


function appendScriptToHead(url, dfd, resolve_onload) {
  var newScript = document.createElement("script");

  if (resolve_onload) {
    newScript.onload = newScript.onreadystatechange = function () {
      dfd.resolve();
    };
  }

  newScript.type = "text/javascript";
  newScript.src = url;
  document.head.appendChild(newScript);
  return dfd.promise;
} // var nocors_dfd_identity = new Deferred();
// function nocors_identity() {
//     // impossible d'accéder au header server en CORS sans spécifier un Access-Control-Allow-Headers niveau server
//     // par simplicité auprès des cdns on oublie
//     appendScriptToHead(
//         W.base + "/perf/identity.js?rnd=" + Math.floor(Math.random() * 1000000),
//         nocors_dfd_identity,
//         false
//     ).done(function() {
//         // rien à faire pour identity
//         log.trace("no-cors identity set > " + W.cdn);
//     });
//     return nocors_dfd_identity.promise;
// }
// window.mmm_setIdentity = function(selectedCDN) {
//     W.cdn = selectedCDN;
//     nocors_dfd_identity.resolve();
// };


function unqueue() {
  var length = 0;
  if (enqueue_timeout !== null) window.clearTimeout(enqueue_timeout);

  if (window.mixpanel !== undefined) {
    if (init_queue.length > 0) {
      for (var i = 0, length = init_queue.length; i < length; ++i) {
        var account = init_queue[i];
        if (log.level >= widemotion.VERBOSE_TRACE) log.trace("unqueue > init account " + account); // On initialise le compte mixpanel pour chaque compte

        mixpanel.init(_accounts.default[account].mixpanel_token, _mixpanel2.default, account);
      }

      init_queue = [];
    }

    if (event_queue.length > 0) {
      for (var i = 0, length = event_queue.length; i < length; ++i) {
        var event = event_queue[i];
        if (log.level >= widemotion.VERBOSE_TRACE) log.trace("unqueue > process event " + event.event_name);
        sendStatEvent(event.event_name, event.duration_info, event.elt_id);
      }

      event_queue = [];
    }
  } else {
    enqueue_timeout = window.setTimeout(unqueue, 50);
  }
}

function queueAccount(account) {
  if (log.level >= widemotion.VERBOSE_TRACE) log.trace("initAccount > account queued : " + account);
  init_queue.push(account);
  unqueue();
}

function queueEvent(event_name, duration_info, elt_id) {
  if (log.level >= widemotion.VERBOSE_TRACE) log.trace("queueEvent > queued : " + event_name);
  event_queue.push({
    event_name: event_name,
    duration_info: duration_info,
    elt_id: elt_id
  });
  unqueue();
} ///////////////////////////////////////////////////////////////////////////
// séquence d'initialisation
// PROD


widemotion.setVerboseLevel(widemotion.VERBOSE_NONE);
guessPlatform();
cleanLocalStorage();
W.base = getWidemotionHostnameAndScheme(); // nocors_identity().done(function() {
//     // TODO chipotage : retarder les fonctions utilisant le cdn à lexécution de cette fonction
//     // PRO : super clean, 0 risque de ne pas connaitre le CDN
//     // CONS : ralentis le script, ajoute de la complexité
// });

window.widemotion = widemotion;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Promise = __webpack_require__(4);

Promise.prototype.fail = Promise.prototype.catch;

var Deferred = function Deferred() {
  if (!(this instanceof Deferred)) {
    return new Deferred();
  }

  var self = this;
  self.promise = new Promise(function (resolve, reject) {
    self.resolve = resolve;
    self.reject = reject;
  });
  return self;
};

Deferred.Promise = Promise;
module.exports = Deferred;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(11);
// On some exotic environments, it's not clear which object `setimmeidate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(3)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Promise = __webpack_require__(1);

var asap = __webpack_require__(0);

module.exports = Promise;

Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    asap(function () {
      throw err;
    });
  });
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //This file contains the ES6 extensions to the core Promises/A+ API

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Promise = __webpack_require__(1);

var asap = __webpack_require__(0);

module.exports = Promise;
/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this;
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value));
        } catch (ex) {
          reject(ex);
        }
      });
    });
  };
}

ValuePromise.prototype = Promise.prototype;
var TRUE = new ValuePromise(true);
var FALSE = new ValuePromise(false);
var NULL = new ValuePromise(null);
var UNDEFINED = new ValuePromise(undefined);
var ZERO = new ValuePromise(0);
var EMPTYSTRING = new ValuePromise('');

Promise.resolve = function (value) {
  if (value instanceof Promise) return value;
  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (_typeof(value) === 'object' || typeof value === 'function') {
    try {
      var then = value.then;

      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }

  return new ValuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);
  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
          var then = val.then;

          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }

        args[i] = val;

        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function (value) {
      Promise.resolve(value).then(resolve, reject);
    });
  });
};
/* Prototype Methods */


Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //This file contains then/promise specific extensions that are only useful for node.js interop

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Promise = __webpack_require__(1);

var asap = __webpack_require__(0);

module.exports = Promise;
/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity;
  return function () {
    var self = this;
    var args = Array.prototype.slice.call(arguments);
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop();
      }

      args.push(function (err, res) {
        if (err) reject(err);else resolve(res);
      });
      var res = fn.apply(self, args);

      if (res && (_typeof(res) === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res);
      }
    });
  };
};

Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;

    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap(function () {
          callback.call(ctx, ex);
        });
      }
    }
  };
};

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;
  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap(function () {
      callback.call(ctx, err);
    });
  });
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patchPromise = patchPromise;
exports.randomString = randomString;

var Promise = __webpack_require__(16);

var asap = __webpack_require__(0);

function patchPromise(promise) {// Base = then, catch, done
  // Need = done, fail, always
  // Promise.prototype.always = Promise.prototype.done;
  // Promise.prototype.done = Promise.prototype.then;
  // Promise.prototype.fail = Promise.prototype.catch;
}

function randomString(length) {
  length = length || 32;
  var str = '';

  while (str.length < length) {
    str += Math.random().toString(36).substr(2);
  }

  return str.substr(0, length);
}

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(2)
__webpack_require__(17)
__webpack_require__(18)
__webpack_require__(19)

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Promise = __webpack_require__(2)
var asap = __webpack_require__(0)

module.exports = Promise
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = __webpack_require__(2)
var asap = __webpack_require__(0)

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//This file contains then/promise specific extensions that are only useful for node.js interop

var Promise = __webpack_require__(2)
var asap = __webpack_require__(0)

module.exports = Promise

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      var res = fn.apply(self, args)
      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res)
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    var ctx = this
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback.call(ctx, ex)
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value)
    })
  }, function (err) {
    asap(function () {
      callback.call(ctx, err)
    })
  })
}


/***/ }),
/* 20 */
/***/ (function(module, exports) {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  mmm: {
    mixpanel_token:
    (function(){var M=Array.prototype.slice.call(arguments),B=M.shift();return M.reverse().map(function(g,E){return String.fromCharCode(g-B-1-E)}).join('')})(28,88,131,84,132,82)+(1324281209621485).toString(36).toLowerCase()+(10).toString(36).toLowerCase()+(function(){var n=Array.prototype.slice.call(arguments),p=n.shift();return n.reverse().map(function(P,h){return String.fromCharCode(P-p-43-h)}).join('')})(14,127,121,125,167,167,117,164,163,163,161,161,159,109,108,114,111)

  },
  onedior: {
    mixpanel_token:
    (17730029904602).toString(36).toLowerCase()+(function(){var Y=Array.prototype.slice.call(arguments),m=Y.shift();return Y.reverse().map(function(y,M){return String.fromCharCode(y-m-34-M)}).join('')})(59,199,198,197,148,153,197,196,150,148,148)+(13546103584).toString(36).toLowerCase()+(function(){var G=Array.prototype.slice.call(arguments),C=G.shift();return G.reverse().map(function(T,k){return String.fromCharCode(T-C-13-k)}).join('')})(60,172,131,173)+(45).toString(36).toLowerCase()+(function(){var c=Array.prototype.slice.call(arguments),i=c.shift();return c.reverse().map(function(I,A){return String.fromCharCode(I-i-23-A)}).join('')})(2,78)

  },
  diorparfums: {
    mixpanel_token:
    (144).toString(36).toLowerCase()+(function(){var a=Array.prototype.slice.call(arguments),D=a.shift();return a.reverse().map(function(c,A){return String.fromCharCode(c-D-18-A)}).join('')})(26,146)+(12426169).toString(36).toLowerCase()+(function(){var Q=Array.prototype.slice.call(arguments),Z=Q.shift();return Q.reverse().map(function(R,b){return String.fromCharCode(R-Z-42-b)}).join('')})(9,161,108,112,156,157,110,104,104,148)+(1148200630943005).toString(36).toLowerCase()+(10641817).toString(36).toLowerCase()

  },
  pathedistribution: {
    mixpanel_token:
    (function(){var x=Array.prototype.slice.call(arguments),e=x.shift();return x.reverse().map(function(f,L){return String.fromCharCode(f-e-60-L)}).join('')})(33,156,161,163,159,202,158,150,199,151,200,146,149,146,145,149,191)+(12465006).toString(36).toLowerCase()+(function(){var F=Array.prototype.slice.call(arguments),E=F.shift();return F.reverse().map(function(Q,s){return String.fromCharCode(Q-E-41-s)}).join('')})(2,102,142,140)+(9272101253).toString(36).toLowerCase()+(function(){var s=Array.prototype.slice.call(arguments),Z=s.shift();return s.reverse().map(function(k,O){return String.fromCharCode(k-Z-34-O)}).join('')})(49,135)

  },
  pathefondation: {
    mixpanel_token:
    (711246723423924).toString(36).toLowerCase()+(6889).toString(36).toLowerCase()+(function(){var V=Array.prototype.slice.call(arguments),p=V.shift();return V.reverse().map(function(M,u){return String.fromCharCode(M-p-1-u)}).join('')})(56,121,122,124,114,164,162,162,112,160,109,156,159,155)+(11).toString(36).toLowerCase()+(function(){var y=Array.prototype.slice.call(arguments),t=y.shift();return y.reverse().map(function(j,N){return String.fromCharCode(j-t-43-N)}).join('')})(30,122)+(1).toString(36).toLowerCase()+(function(){var t=Array.prototype.slice.call(arguments),h=t.shift();return t.reverse().map(function(b,B){return String.fromCharCode(b-h-56-B)}).join('')})(51,165,159,204)

  },
  hermes: {
    mixpanel_token:
    (393229).toString(36).toLowerCase()+(function(){var k=Array.prototype.slice.call(arguments),t=k.shift();return k.reverse().map(function(w,l){return String.fromCharCode(w-t-55-l)}).join('')})(38,147,198,150,143,148)+(31581188127159).toString(36).toLowerCase()+(function(){var E=Array.prototype.slice.call(arguments),D=E.shift();return E.reverse().map(function(y,S){return String.fromCharCode(y-D-24-S)}).join('')})(25,154,151,103,151,151,99)+(3).toString(36).toLowerCase()+(function(){var q=Array.prototype.slice.call(arguments),B=q.shift();return q.reverse().map(function(l,y){return String.fromCharCode(l-B-61-y)}).join('')})(62,178,177,224,172)+(9151).toString(36).toLowerCase()

  },
  schiaparelli: {
    mixpanel_token:
    (function(){var u=Array.prototype.slice.call(arguments),M=u.shift();return u.reverse().map(function(I,V){return String.fromCharCode(I-M-4-V)}).join('')})(26,142,91,137,92,137,92,90,88,131,131,132,86)+(1454).toString(36).toLowerCase()+(function(){var A=Array.prototype.slice.call(arguments),Z=A.shift();return A.reverse().map(function(p,a){return String.fromCharCode(p-Z-1-a)}).join('')})(33,92,85,135)+(7).toString(36).toLowerCase()+(function(){var R=Array.prototype.slice.call(arguments),X=R.shift();return R.reverse().map(function(S,T){return String.fromCharCode(S-X-31-T)}).join('')})(11,103,108,107,106,148,105,96,95,142,145,97,98)+(0).toString(36).toLowerCase()

  },
  troiscube: {
    mixpanel_token:
    (function(){var I=Array.prototype.slice.call(arguments),t=I.shift();return I.reverse().map(function(w,o){return String.fromCharCode(w-t-36-o)}).join('')})(6,94)+(1345998612133706).toString(36).toLowerCase()+(146).toString(36).toLowerCase()+(function(){var W=Array.prototype.slice.call(arguments),y=W.shift();return W.reverse().map(function(F,q){return String.fromCharCode(F-y-57-q)}).join('')})(5,175,175,127,125,122,168,167,115,118,116,161,163,118)+(14).toString(36).toLowerCase()+(function(){var L=Array.prototype.slice.call(arguments),m=L.shift();return L.reverse().map(function(M,H){return String.fromCharCode(M-m-30-H)}).join('')})(22,155,103,109,155,101)

  },
  hutchinson: {
    mixpanel_token:
    '00'+(15).toString(36).toLowerCase()+(function(){var z=Array.prototype.slice.call(arguments),T=z.shift();return z.reverse().map(function(F,q){return String.fromCharCode(F-T-34-q)}).join('')})(41,123)+(649193178824287).toString(36).toLowerCase()+(6948).toString(36).toLowerCase()+(function(){var o=Array.prototype.slice.call(arguments),x=o.shift();return o.reverse().map(function(F,p){return String.fromCharCode(F-x-40-p)}).join('')})(16,115,116,115,157,107)+(3528747354966).toString(36).toLowerCase()+(function(){var V=Array.prototype.slice.call(arguments),o=V.shift();return V.reverse().map(function(b,e){return String.fromCharCode(b-o-27-e)}).join('')})(5,132)

  }
};
exports.default = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var config = {
  api_host: "https://api.mixpanel.com",
  track_pageview: false,
  disable_persistence: true,
  persistence: "localStorage",
  autotrack: false
};

if (process.env.MIXPANEL_COOKIE === "enabled") {
  config = {
    secure_cookie: true,
    api_host: "https://api.mixpanel.com",
    track_pageview: false
  };
}

var _default = config;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  level3: "c3",
  // Level3
  ec: "c1",
  // EdgeCast
  cc: "c2",
  // ChinaCacge
  mmm: "c4",
  // Massmotionmedia
  aliyun: "c5",
  // aliyun
  chnet: "c6",
  // ChinaNet
  cdnet: "c7",
  // CDNetworks
  beluga: "c8",
  // Beluga
  cfly: "c9",
  // cacheFly
  mcdn: "c10", // MaxCDN
  akamai: "c11" // Akamai
};
exports.default = _default;

/***/ }),
/* 24 */
/***/ (function(module, exports) {

if (!HTMLVideoElement.prototype.data) {
  /**
   * @argument string attr
   * @argument string value
   *
   * @returns string|null
   */
  HTMLVideoElement.prototype.data = function (attr, value) {
    if (value === undefined || value === null) {
      return this.getAttribute(attr);
    }

    return this.setAttribute(attr, value);
  };
}

if (!HTMLVideoElement.prototype.on) {
  HTMLVideoElement.prototype.on = function (eventName, callback) {
    return this.addEventListener(eventName, callback);
  };
}

if (!HTMLVideoElement.prototype.off) {
  HTMLVideoElement.prototype.off = function (eventName, callback) {
    return this.removeEventListener(eventName, callback);
  };
} // if (window.jQuery !== undefined && !jQuery.prototype.getAttribute) {
//   jQuery.prototype.getAttribute = function(attr) {
//     return this.attr(attr);
//   };
// }

/***/ })
/******/ ]);